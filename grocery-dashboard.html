<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Grocery Intelligence Dashboard</title>
    <script src="https://cdn.tailwindcss.com"></script>
  </head>
  <body class="bg-slate-50 text-slate-900 min-h-screen">
    <div id="root"></div>
    <script type="module">
      import React, { useEffect, useMemo, useRef, useState } from "https://esm.sh/react@18.3.1";
      import { createRoot } from "https://esm.sh/react-dom@18.3.1/client";

      const createId = () => {
        if (typeof crypto !== "undefined" && typeof crypto.randomUUID === "function") {
          return crypto.randomUUID();
        }
        return `id-${Date.now()}-${Math.random().toString(16).slice(2)}`;
      };

      const useLazy = (factory) => {
        const [mod, setMod] = useState(null);
        useEffect(() => {
          let live = true;
          (async () => {
            try {
              const m = await factory();
              if (live) setMod(m);
            } catch (e) {
              console.error("Failed to load module", e);
              if (live) setMod(null);
            }
          })();
          return () => {
            live = false;
          };
        }, [factory]);
        return mod;
      };

      const CATEGORIES = [
        "Produce",
        "Pantry",
        "Dairy",
        "Meat/Seafood",
        "Snacks",
        "Bakery",
        "Household",
        "Specialty/Health",
        "Dining Out",
      ];

      const STORE_HINTS = [
        { key: "woolworths", label: "Woolworths" },
        { key: "coles", label: "Coles" },
        { key: "aldi", label: "ALDI" },
        { key: "officeworks", label: "Officeworks" },
        { key: "slow grain", label: "Slow Grain" },
        { key: "bws", label: "BWS" },
      ];

      const CATEGORY_KEYWORDS = {
        Produce: [
          "banana",
          "apple",
          "carrot",
          "mandarin",
          "tomato",
          "cucumber",
          "pumpkin",
          "broccolini",
          "avocado",
          "lettuce",
          "berries",
          "blueberry",
          "raspberry",
          "blackberry",
          "lemon",
          "potato",
          "sweet potato",
        ],
        Pantry: [
          "pasta",
          "rice",
          "sauce",
          "tuna",
          "beans",
          "medammas",
          "dates",
          "anchov",
          "capers",
          "oats",
          "cereal",
          "cluster",
          "wrap",
          "spaghetti",
          "ketchup",
          "sugar",
          "salt",
        ],
        Dairy: ["milk", "yogh", "yogurt", "cheese", "mozz", "butter", "cream"],
        "Meat/Seafood": ["chicken", "mince", "beef", "salmon", "prawn", "meatball", "bacon", "lamb", "turkey", "praw"],
        Snacks: ["chips", "biscuit", "chocolate", "bar", "snack", "cracker", "lolly"],
        Bakery: ["bread", "loaf", "bakery", "slow grain", "spelt", "sourdough", "pita", "wrap"],
        Household: [
          "tissue",
          "wipes",
          "detergent",
          "paper towel",
          "nappy",
          "napkin",
          "cylinder",
          "sodastream",
          "alcohol wipes",
        ],
        "Specialty/Health": [
          "manuka",
          "organic",
          "oatly",
          "aloe",
          "chia",
          "beet",
          "kombucha",
          "only organic",
          "macro",
        ],
      };

      const defaultData = () => ({
        id: createId(),
        store: "",
        date: new Date().toISOString().slice(0, 10),
        time: "",
        total: 0,
        items: [],
        sourceName: "",
      });

      function classifyCategory(desc) {
        const s = String(desc || "").toLowerCase();
        for (const [cat, keys] of Object.entries(CATEGORY_KEYWORDS)) {
          if (keys.some((k) => s.includes(k))) return cat;
        }
        return "Pantry";
      }

      function inferStore(text) {
        const s = String(text || "").toLowerCase();
        for (const h of STORE_HINTS) {
          if (s.includes(h.key)) return h.label;
        }
        if (/abn\s+88\s+000\s+014\s+675/i.test(s)) return "Woolworths";
        if (/coles supermarkets australia/i.test(s)) return "Coles";
        if (/aldi stores/i.test(s)) return "ALDI";
        return "";
      }

      function parseTotal(text) {
        const s = String(text || "");
        const m = s.match(/\bTOTAL\s*\$?\s*([0-9]+\.[0-9]{2})/i);
        if (m) return parseFloat(m[1]);
        const all = [...s.matchAll(/\$\s*([0-9]+\.[0-9]{2})/g)].map((x) => parseFloat(x[1]));
        return all.length ? all[all.length - 1] : 0;
      }

      function parseDate(text) {
        const s = String(text || "");
        const d = s.match(/\b\d{1,2}\/\d{1,2}\/\d{2,4}\b/);
        if (!d) return new Date().toISOString().slice(0, 10);
        const parts = d[0].split("/");
        const [dd, mm, yy] = [parts[0], parts[1], parts[2]];
        const yyyy = yy.length === 2 ? `20${yy}` : yy;
        return `${yyyy}-${mm.padStart(2, "0")}-${dd.padStart(2, "0")}`;
      }

      function tokenizeItems(text) {
        const lines = String(text || "")
          .split(/\n|\r/)
          .map((l) => l.trim())
          .filter(Boolean);
        const items = [];
        for (const ln of lines) {
          const kg = ln.match(/@\s*\$?([0-9]+\.?[0-9]*)\s*\/kg\)?\s*([= ]\s*)?\$?([0-9]+\.[0-9]{2})?/i);
          const price = ln.match(/\$\s*([0-9]+\.[0-9]{2})\b(?!.*\$)/);
          if (kg && kg[3]) {
            const desc = ln.replace(/\$[0-9]+\.[0-9]{2}.*/, "");
            items.push({ desc, qty: 1, price: parseFloat(kg[3]), category: classifyCategory(desc) });
            continue;
          }
          if (price) {
            const val = parseFloat(price[1]);
            if (/total/i.test(ln)) continue;
            const desc = ln.replace(/\$\s*[0-9]+\.[0-9]{2}.*/, "");
            if (/approved|change|card|aid|merchant|arqc|thanks|coupon|save/i.test(desc)) continue;
            if (desc.length < 3) continue;
            items.push({ desc, qty: 1, price: val, category: classifyCategory(desc) });
          }
        }
        const unique = [];
        const seen = new Set();
        for (const it of items) {
          const key = `${(it.desc || "").toLowerCase()}|${it.price}`;
          if (!seen.has(key)) {
            seen.add(key);
            unique.push(it);
          }
        }
        return unique.slice(0, 200);
      }

      function GroceryDashboard() {
        const [docs, setDocs] = useState([]);
        const [busy, setBusy] = useState(false);
        const [error, setError] = useState("");
        const fileRef = useRef(null);

        useEffect(() => {
          try {
            const raw = localStorage.getItem("grocery_docs_v1");
            if (raw) setDocs(JSON.parse(raw));
          } catch (err) {
            console.warn("Failed to load saved docs", err);
          }
        }, []);
        useEffect(() => {
          try {
            localStorage.setItem("grocery_docs_v1", JSON.stringify(docs));
          } catch (err) {
            console.warn("Failed to persist docs", err);
          }
        }, [docs]);

        const Tesseract = useLazy(() =>
          import("https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.esm.min.js")
        );
        const pdfjs = useLazy(async () => {
          const pdfjsLib = await import(
            "https://cdn.jsdelivr.net/npm/pdfjs-dist@4.3.136/build/pdf.min.mjs"
          );
          try {
            pdfjsLib.GlobalWorkerOptions.workerSrc =
              "https://cdn.jsdelivr.net/npm/pdfjs-dist@4.3.136/build/pdf.worker.min.mjs";
          } catch (err) {
            console.warn("Falling back to no worker", err);
            pdfjsLib.GlobalWorkerOptions.workerSrc = undefined;
            pdfjsLib.disableWorker = true;
          }
          return pdfjsLib;
        });

        async function readAsText(file) {
          const type = file.type || "";
          if (type.includes("pdf")) {
            if (!pdfjs) {
              throw new Error("PDF parser is still loading. Please try again in a moment.");
            }
            const buf = await file.arrayBuffer();
            const pdf = await pdfjs.getDocument({ data: buf }).promise;
            let text = "";
            for (let i = 1; i <= pdf.numPages; i += 1) {
              const page = await pdf.getPage(i);
              const content = await page.getTextContent();
              text += content.items.map((it) => it.str).join(" \n ") + "\n";
            }
            return text.trim();
          }
          if (type.startsWith("image/") || !type) {
            if (!Tesseract) {
              throw new Error("OCR engine is still loading. Please try again in a moment.");
            }
            const { data } = await Tesseract.recognize(file, "eng", { logger: () => {} });
            return (data.text || "").trim();
          }
          return (await file.text()).trim();
        }

        async function handleFiles(list) {
          setBusy(true);
          setError("");
          try {
            const files = Array.from(list || []);
            if (!files.length) {
              setBusy(false);
              return;
            }
            const parsed = await Promise.all(
              files.map(async (f) => {
                const rawText = await readAsText(f);
                const store = inferStore(rawText);
                const date = parseDate(rawText);
                const total = parseTotal(rawText);
                const items = tokenizeItems(rawText);
                return {
                  ...defaultData(),
                  store,
                  date,
                  total,
                  items,
                  sourceName: f.name,
                  rawText,
                };
              })
            );
            setDocs((d) => [...parsed, ...d]);
          } catch (e) {
            console.error(e);
            setError(String(e?.message || e));
          } finally {
            setBusy(false);
          }
        }

        function updateDoc(id, patch) {
          setDocs((prev) => prev.map((d) => (d.id === id ? { ...d, ...patch } : d)));
        }
        function removeDoc(id) {
          setDocs((prev) => prev.filter((d) => d.id !== id));
        }

        const spendByStore = useMemo(() => {
          const map = new Map();
          for (const d of docs) {
            const key = d.store || d.sourceName || "Unknown";
            const total = Number(d.total) || d.items.reduce((s, it) => s + Number(it.price || 0), 0);
            map.set(key, (map.get(key) || 0) + total);
          }
          return Array.from(map, ([store, total]) => ({ store, total: Number(total.toFixed(2)) }));
        }, [docs]);

        const spendByCategory = useMemo(() => {
          const agg = Object.fromEntries(CATEGORIES.map((c) => [c, 0]));
          for (const d of docs) {
            for (const it of d.items) {
              const cat = it.category || "Pantry";
              agg[cat] = (agg[cat] || 0) + Number(it.price || 0);
            }
          }
          return Object.entries(agg)
            .map(([name, value]) => ({ name, value: Number(value.toFixed(2)) }))
            .filter((x) => x.value > 0);
        }, [docs]);

        const totalSpend = spendByStore.reduce((s, x) => s + x.total, 0);
        const workerOk = !!pdfjs && (!!pdfjs.GlobalWorkerOptions?.workerSrc || pdfjs.disableWorker === true);

        function exportCSV() {
          const rows = [["id", "store", "date", "time", "total", "source", "desc", "qty", "price", "category"]];
          for (const d of docs) {
            if (!d.items.length) {
              rows.push([d.id, d.store, d.date, d.time, d.total, d.sourceName, "", 1, d.total, ""]);
            }
            for (const it of d.items) {
              rows.push([
                d.id,
                d.store,
                d.date,
                d.time,
                d.total,
                d.sourceName,
                it.desc,
                it.qty ?? 1,
                it.price,
                it.category,
              ]);
            }
          }
          const csv = rows
            .map((r) => r.map((x) => `"${String(x ?? "").replaceAll('"', '""')}"`).join(","))
            .join("\n");
          const blob = new Blob([csv], { type: "text/csv" });
          const a = document.createElement("a");
          a.href = URL.createObjectURL(blob);
          a.download = "grocery_dashboard_export.csv";
          a.click();
          URL.revokeObjectURL(a.href);
        }

        function addManual() {
          setDocs((d) => [{ ...defaultData(), store: "Manual Entry", sourceName: "Manual" }, ...d]);
        }

        const [tests, setTests] = useState([]);
        useEffect(() => {
          const cases = [];
          cases.push({
            name: "parseDate dd/mm/yyyy",
            expect: "2025-10-14",
            got: parseDate("POS 14/10/2025 16:13 TOTAL $12.34"),
          });
          cases.push({ name: "parseTotal TOTAL $x", expect: 12.34, got: parseTotal("TOTAL $12.34\nThanks!") });
          cases.push({
            name: "inferStore woolworths abn",
            expect: "Woolworths",
            got: inferStore("ABN 88 000 014 675 WOOLWORTHS"),
          });
          cases.push({
            name: "classify pizza sauce => Pantry",
            expect: "Pantry",
            got: classifyCategory("Della Rosa Tomato Pizza Sauce $2.50"),
          });
          const toks = tokenizeItems("Banana Cav @ $3.00/kg = $3.58\nCereal Clusters $4.50\nTOTAL $8.08");
          cases.push({ name: "tokenizeItems count", expect: 2, got: toks.length });
          setTests(cases.map((c) => ({ ...c, pass: String(c.got) === String(c.expect) })));
        }, []);

        return (
          <div className="p-6 space-y-6 max-w-6xl mx-auto">
            <header className="flex flex-col md:flex-row md:items-center md:justify-between gap-3">
              <h1 className="text-2xl font-semibold">Grocery Intelligence Dashboard</h1>
              <div className="flex gap-2">
                <button
                  className="px-3 py-2 border rounded"
                  onClick={() => fileRef.current?.click()}
                  disabled={busy}
                >
                  Upload receipts
                </button>
                <input
                  ref={fileRef}
                  type="file"
                  className="hidden"
                  multiple
                  accept="image/*,application/pdf"
                  onChange={(e) => handleFiles(e.target.files)}
                />
                <button className="px-3 py-2 border rounded" onClick={addManual}>
                  Manual
                </button>
                <button className="px-3 py-2 border rounded" onClick={exportCSV}>
                  Export CSV
                </button>
              </div>
            </header>

            {!workerOk && (
              <div className="border border-amber-300 bg-amber-50 text-amber-800 p-3 text-sm rounded">
                PDF worker is in fallback mode. Parsing will still work but may be slower.
              </div>
            )}
            {error && (
              <div className="border border-red-300 bg-red-50 text-red-800 p-3 text-sm rounded">{error}</div>
            )}

            <section className="grid md:grid-cols-3 gap-4">
              <div className="border rounded p-4 bg-white/80 backdrop-blur">
                <div className="text-sm text-gray-600">Total Spend</div>
                <div className="text-3xl font-bold">${totalSpend.toFixed(2)}</div>
                <div className="text-xs text-gray-500">Across {docs.length} receipts</div>
              </div>
              <div className="border rounded p-4 bg-white/80 backdrop-blur">
                <div className="text-sm text-gray-600">Top Store</div>
                {spendByStore.length ? (
                  <div>
                    <div className="text-xl font-semibold">
                      {[...spendByStore].sort((a, b) => b.total - a.total)[0].store}
                    </div>
                    <div className="text-xs text-gray-500">
                      ${[...spendByStore].sort((a, b) => b.total - a.total)[0].total.toFixed(2)}
                    </div>
                  </div>
                ) : (
                  <div className="text-xs text-gray-500">Upload to populate…</div>
                )}
              </div>
              <div className="border rounded p-4 bg-white/80 backdrop-blur">
                <div className="text-sm text-gray-600">Avg per Receipt</div>
                <div className="text-3xl font-bold">
                  ${docs.length ? (totalSpend / docs.length).toFixed(2) : "0.00"}
                </div>
                <div className="text-xs text-gray-500">Heuristic based on detected totals</div>
              </div>
            </section>

            <section className="border rounded p-4 bg-white/80 backdrop-blur">
              <h2 className="font-semibold mb-3">Spend by Store</h2>
              <div className="overflow-x-auto">
                <table className="w-full text-sm">
                  <thead>
                    <tr className="text-left text-gray-600">
                      <th className="py-1 pr-2">Store</th>
                      <th className="py-1 pr-2">Total ($)</th>
                    </tr>
                  </thead>
                  <tbody>
                    {spendByStore.map((r) => (
                      <tr key={r.store} className="border-t">
                        <td className="py-1 pr-2">{r.store}</td>
                        <td className="py-1 pr-2">{r.total.toFixed(2)}</td>
                      </tr>
                    ))}
                  </tbody>
                </table>
              </div>
            </section>

            <section className="border rounded p-4 bg-white/80 backdrop-blur">
              <h2 className="font-semibold mb-3">Spend by Category</h2>
              <div className="overflow-x-auto">
                <table className="w-full text-sm">
                  <thead>
                    <tr className="text-left text-gray-600">
                      <th className="py-1 pr-2">Category</th>
                      <th className="py-1 pr-2">Total ($)</th>
                    </tr>
                  </thead>
                  <tbody>
                    {spendByCategory.map((r) => (
                      <tr key={r.name} className="border-t">
                        <td className="py-1 pr-2">{r.name}</td>
                        <td className="py-1 pr-2">{r.value.toFixed(2)}</td>
                      </tr>
                    ))}
                  </tbody>
                </table>
              </div>
            </section>

            <section className="border rounded p-4 bg-white/80 backdrop-blur">
              <h2 className="font-semibold mb-3">Parsed Receipts</h2>
              <div className="text-xs text-gray-500 mb-2">OCR is heuristic — click to edit values.</div>
              <div className="overflow-x-auto">
                <table className="w-full text-sm">
                  <thead>
                    <tr className="text-left text-gray-600">
                      <th className="py-1 pr-2 min-w-[160px]">Store</th>
                      <th className="py-1 pr-2 min-w-[110px]">Date</th>
                      <th className="py-1 pr-2 min-w-[420px]">Items</th>
                      <th className="py-1 pr-2 min-w-[120px]">Total</th>
                      <th></th>
                    </tr>
                  </thead>
                  <tbody>
                    {docs.map((d) => (
                      <tr key={d.id} className="align-top border-t">
                        <td className="py-2 pr-2">
                          <input
                            className="border rounded px-2 py-1 w-full"
                            value={d.store}
                            placeholder="Store"
                            onChange={(e) => updateDoc(d.id, { store: e.target.value })}
                          />
                          <div className="text-[10px] text-gray-500 mt-1">{d.sourceName}</div>
                        </td>
                        <td className="py-2 pr-2">
                          <input
                            className="border rounded px-2 py-1 w-full"
                            value={d.date}
                            onChange={(e) => updateDoc(d.id, { date: e.target.value })}
                          />
                          {d.time && <div className="text-[10px] text-gray-500">{d.time}</div>}
                        </td>
                        <td className="py-2 pr-2">
                          <div className="space-y-2">
                            {d.items.map((it, idx) => (
                              <div key={idx} className="grid grid-cols-12 gap-2 items-center">
                                <input
                                  className="col-span-6 border rounded px-2 py-1"
                                  value={it.desc}
                                  onChange={(e) => {
                                    const items = [...d.items];
                                    items[idx] = { ...it, desc: e.target.value };
                                    updateDoc(d.id, { items });
                                  }}
                                />
                                <input
                                  className="col-span-2 border rounded px-2 py-1"
                                  type="number"
                                  step="0.01"
                                  value={it.price}
                                  onChange={(e) => {
                                    const items = [...d.items];
                                    items[idx] = { ...it, price: parseFloat(e.target.value || "0") };
                                    updateDoc(d.id, { items });
                                  }}
                                />
                                <select
                                  className="col-span-3 border rounded px-2 py-1"
                                  value={it.category}
                                  onChange={(e) => {
                                    const items = [...d.items];
                                    items[idx] = { ...it, category: e.target.value };
                                    updateDoc(d.id, { items });
                                  }}
                                >
                                  {CATEGORIES.map((c) => (
                                    <option key={c} value={c}>
                                      {c}
                                    </option>
                                  ))}
                                </select>
                                <button
                                  className="col-span-1 text-red-600"
                                  onClick={() => {
                                    const items = [...d.items];
                                    items.splice(idx, 1);
                                    updateDoc(d.id, { items });
                                  }}
                                >
                                  ✕
                                </button>
                              </div>
                            ))}
                            <button
                              className="px-2 py-1 border rounded text-xs"
                              onClick={() => {
                                updateDoc(d.id, {
                                  items: [
                                    ...d.items,
                                    { desc: "New item", qty: 1, price: 0, category: "Pantry" },
                                  ],
                                });
                              }}
                            >
                              + Add line
                            </button>
                          </div>
                        </td>
                        <td className="py-2 pr-2">
                          <input
                            className="border rounded px-2 py-1 w-full"
                            type="number"
                            step="0.01"
                            value={d.total}
                            onChange={(e) => updateDoc(d.id, { total: parseFloat(e.target.value || "0") })}
                          />
                          <div className="text-[10px] text-gray-500">
                            Sum items: ${d.items.reduce((s, it) => s + (Number(it.price) || 0), 0).toFixed(2)}
                          </div>
                        </td>
                        <td className="py-2 pr-2">
                          <button className="px-2 py-1 border rounded text-xs" onClick={() => removeDoc(d.id)}>
                            Delete
                          </button>
                        </td>
                      </tr>
                    ))}
                  </tbody>
                </table>
              </div>
            </section>

            <section className="border rounded p-4 bg-white/80 backdrop-blur">
              <h2 className="font-semibold mb-2">Self-tests</h2>
              <div className="overflow-x-auto">
                <table className="w-full text-sm">
                  <thead>
                    <tr className="text-left text-gray-600">
                      <th className="py-1 pr-2">Test</th>
                      <th className="py-1 pr-2">Expected</th>
                      <th className="py-1 pr-2">Got</th>
                      <th className="py-1 pr-2">Pass</th>
                    </tr>
                  </thead>
                  <tbody>
                    {tests.map((t, i) => (
                      <tr key={i} className="border-t">
                        <td className="py-1 pr-2">{t.name}</td>
                        <td className="py-1 pr-2">{String(t.expect)}</td>
                        <td className="py-1 pr-2">{String(t.got)}</td>
                        <td className="py-1 pr-2">{t.pass ? "✅" : "❌"}</td>
                      </tr>
                    ))}
                  </tbody>
                </table>
              </div>
            </section>

            <section className="border rounded p-4 bg-white/80 backdrop-blur">
              <h2 className="font-semibold mb-2">Open Question for Expected Behaviour</h2>
              <p className="text-sm text-gray-700">
                When <strong>multiple totals</strong> exist in a receipt (e.g., subtotal, savings, total), which rule should we enforce
                for the final amount?
              </p>
              <ol className="list-decimal ml-5 text-sm text-gray-700 space-y-1 mt-2">
                <li>A: Always pick the <strong>last</strong> currency-like amount on the page.</li>
                <li>B: Prefer the line that starts with <strong>"TOTAL"</strong>.</li>
                <li>C: Use the <strong>largest</strong> amount found.</li>
              </ol>
              <p className="text-xs text-gray-500 mt-1">
                Reply which rule (A/B/C) you prefer and I’ll lock it in code.
              </p>
            </section>
          </div>
        );
      }

      const root = createRoot(document.getElementById("root"));
      root.render(<GroceryDashboard />);
    </script>
  </body>
</html>
